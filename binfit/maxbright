#!@@PATH_TO_MAXBRWISH@@/maxbrwish
# -*- Mode: tcl -*-
#
# maxbright
# Created:     Sat Aug  9 20:45:52 1997 by Koehler@Lisa
# Last Change: Tue Feb  5 17:45:08 2002
#
#############################################################################
#
# NAME
#   maxbright.tk - tcl-script for MaxBright-TNG
#
# SYNOPSIS
#   maxbright.tk
#
# DESCRIPTION
#   read the source :-)
#
#   OPT  - array of user defined options (debug, verbose, colors, ...)
#   PRIV - array of application's private values to remember
#   V    - array of widget related variables
#
# AUTHOR
#   This file was automatically generated by rpt
#
# --------------------------------------------------------------------
# MODIFICATION HISTORY
#   when      who       what
#   --------- --------- ---------------------------------------------
#   09.08.97  koehler   created with rpt
# ====================================================================

set OPT(debug) 1
set OPT(ghostview) "@@GHOSTVIEW@@"

if {[info exists env(TCL_RK_LIBRARY)] && [file isdir $env(TCL_RK_LIBRARY)]} {
    # all right
} elseif [file isdir "@@PATH_TO_TCL_RK@@"] {
    set env(TCL_RK_LIBRARY) "@@PATH_TO_TCL_RK@@"
} elseif [file isdir "./tcl-rk"] {
    set env(TCL_RK_LIBRARY) "[pwd]/tcl-rk"
} else {
    puts "No Tcl-RK library found!"
}
lappend auto_path $env(TCL_RK_LIBRARY)
rkInit

set Pmin(Maxbright)  ""; set Pmax(Maxbright)  ""
set Pmin(Visibility) ""; set Pmax(Visibility) ""
set Pmin(KT-Phase)   ""; set Pmax(KT-Phase)   ""
set Pmin(Bisp-Phase) ""; set Pmax(Bisp-Phase) ""

# ====================================================================
#  Menu related procedures
# ====================================================================

proc display {fname} {
    if [catch "exec xpaget ds9 version"] {
	# no ds9 present, replicate a new one
	exec ds9 $fname &
    } else {
	exec xpaset -p ds9 file "[pwd]/$fname"
    }
}

# --------------------------------------------------------------------
#  rpt_FilePrint
# --------------------------------------------------------------------

proc rpt_FilePrint {} {
    global OPT V root
    if $OPT(debug) {puts "DEBUG: rpt_FilePrint()"}

    if {[regsub {\.fits.*$} $root "" base] == 0} { set base $root }
    append base "_MB"
    if $OPT(debug) { puts "hardcopy in $base..."}

    wm iconify .
    pgclose
    pgopen "$base-Gfx.ps/PS"
    plot_graph
    pgclose
    update idletasks
    #
    # create "MaxBright"-files
    #
    create_clock
    if {$V(Visib)  != ""} { write_maxbright "vis" "$base.mbv" }
    if {$V(KTphas) != "" || $V(Biphas) != ""} { write_maxbright "pha" "$base.mbp" }
    if [winfo exist .cl] { wm withdraw .cl; update}
    #
    # create TeX-File
    #
    set tfp [open "$base.tex" "w"]
    puts $tfp "%% created by maxbrightTNG"
    puts $tfp "\\magnification=\\magstep1\\parindent0pt"
    puts $tfp "\\input psfig.sty\n\\pssilent"
    puts $tfp "\\voffset1cm\n"
    puts $tfp "\\headline={\\centerline{\\bf $V(Title)}}"
    puts $tfp "\\footline={\\centerline{[clock format [clock seconds]]}}\n"

    puts $tfp "\\font\\eightpt=cmr8"
    puts $tfp "\\vfill\\vbox{%%"
    puts $tfp "\\centerline{Maximum Flux Ratio}\\bigskip"
    puts $tfp "\\centerline{\\hskip-1truecm\\psfig{figure=$base-Gfx.ps,width=\\hsize,angle=270}}"
    puts $tfp "\\centerline{\\eightpt Pixel}}\n\\bigskip\n"

    puts $tfp "\\catcode`\\_=12\n\\centerline{\\vbox{\\halign{\\strut\\hfil# & #\\hfil\\cr"
    if {$V(Visib)   != ""} { puts $tfp "       Visibility: & \\tt $V(Visib)  \\cr" }
    if {$V(Dvisi)   != ""} { puts $tfp " Delta Visibility: & \\tt $V(Dvisi)  \\cr" }
    if {$V(KTphas)  != ""} { puts $tfp "         KT-Phase: & \\tt $V(KTphas) \\cr" }
    if {$V(DKTphas) != ""} { puts $tfp "   Delta KT-Phase: & \\tt $V(DKTphas)\\cr" }
    if {$V(Biphas)  != ""} { puts $tfp "       Bisp-Phase: & \\tt $V(Biphas) \\cr" }
    if {$V(DBiphas) != ""} { puts $tfp " Delta Bisp-Phase: & \\tt $V(DBiphas)\\cr" }
    if {$V(Mask)    != ""} { puts $tfp "    Badpixel-Mask: & \\tt $V(Mask)   \\cr" }
    puts $tfp "	Projection Radius: & \$$V(Rmin)\\ldots$V(Rmax)\$ pixels\\cr"
    puts $tfp "	Projection Angles: & \$$V(PAmin)^\\circ\\ldots$V(PAmax)^\\circ,\\hbox{ step } $V(PAstep)^\\circ\$\\cr"
    puts $tfp "}}}\n\\bye"
    close $tfp

    catch { exec tex "$base.tex" >&@stdout }
    catch { exec dvips "$base.dvi" >&@stdout }
    catch { exec $OPT(ghostview) "$base.ps" }
    exec rm "$base.log" "$base-Gfx.ps"

    wm deiconify .
    pgopen ".f1.plot/xtk"
    .f1.plot setcursor cross 14 42 3
    plot_graph
}


# --------------------------------------------------------------------
#  rpt_FileEditMask
# --------------------------------------------------------------------

set hist(pgid) ""

proc make_vis_img {} {
    global OPT V Pmin Pmax vimg_h vimg_w

    regsub {.*/} $V(Visib) {} vpgm
    set vpgm "/tmp/${vpgm}_MB.pgm"
    vistopgm $vpgm $V(Rmax) $Pmin(Visibility) $Pmax(Visibility)
    image create photo vimg -file $vpgm -palette 100
    exec rm $vpgm
    set vimg_h [expr [image height vimg]*2]
    set vimg_w [expr [image width  vimg]*2]
    image create photo vimg2 -height $vimg_h -width $vimg_w -palette 100
    vimg2 copy vimg -zoom 2
    # vimg copy vimg -zoom 2 -- tut nicht mehr in tk8.0

    if {$V(Mask) != ""} {
	regsub {.*/} $V(Mask) {} mxbm
	set mxbm "/tmp/${mxbm}_MB.xbm"
	masktopbm $mxbm

	image create bitmap mimg2 -file $mxbm -foregro blue
	exec rm $mxbm
    } else {
	image create photo mimg2 -height $vimg_h -width $vimg_w -palette 2
    }
}

proc rpt_FileEditMask {} {
    global OPT V Pmin Pmax hist vimg_h vimg_w
    if $OPT(debug) {puts "DEBUG: rpt_FileEditMask()"}

    # eigentlich erstmal visbility-dial

    if [winfo exists .vd] {destroy .vd}
    toplevel .vd
    wm geometry .vd -20+20
    wm title .vd {maxbright visibility dial}
    wm resizable .vd 0 0
    make_vis_img
    canvas .vd.c -height $vimg_h -width [expr $vimg_w+140] -closeenough 3
    .vd.c create image 1 1 -anchor nw -image vimg2
    .vd.c create image 1 1 -anchor nw -image mimg2
    .vd.c create oval 0 0 1 1 -outline red -tags Rmax
    .vd.c create oval 0 0 1 1 -outline red -tags Rmin
    cnv_circle [expr 2*$V(Rmax)] Rmax
    cnv_circle [expr 2*$V(Rmin)] Rmin

    .vd.c bind Rmax  <1>		{ dial_rad Rmax %x %y }
    .vd.c bind Rmax  <B1-Motion>	{ dial_rad Rmax %x %y }
    .vd.c bind Rmax  <ButtonRelease-1>	{ dial_rad Rmax %x %y; plot_graph }
    .vd.c bind Rmin  <1>		{ dial_rad Rmin %x %y }
    .vd.c bind Rmin  <B1-Motion>	{ dial_rad Rmin %x %y }
    .vd.c bind Rmin  <ButtonRelease-1>	{ dial_rad Rmin %x %y; plot_graph }
    pack .vd.c -side left

    set hist(size) [expr $vimg_h-32]
    set hist(base) [expr $vimg_h-12] ;# da wo min auf'm Schirm ist
    set hist(all)  [histogram $hist(size) $V(Rmax)]
    set hist(minx) [lindex $hist(all) 0]
    set hist(maxx) [lindex $hist(all) 1]
    set hist(step) [lindex $hist(all) 2]
    set hist(y)    [lrange $hist(all) 3 end]
    set hist(maxy) 0
    foreach h $hist(y) { if {$hist(maxy) < $h} { set hist(maxy) $h}}

    set yp  [expr $vimg_h +  4]
    set lft [expr $vimg_w + 10]

    .vd.c create text $lft  1  -fill white -anchor nw -text $hist(maxx)
    .vd.c create text $lft $yp -fill white -anchor sw -text $hist(minx)
    incr yp -16

    foreach h $hist(y) {
	.vd.c create line $lft $yp [expr $lft + 1 + $h*100/$hist(maxy)] $yp -fill yellow
	incr yp -1
    }
    set rgt [expr $lft + 100 - 3]
    set val $Pmin(Visibility)
    set hist(minyp) $hist(base)	;# pixel-pos des Minimum-sliders
    if {$val != ""} {
	incr hist(minyp) -[expr round(($val-$hist(minx)) / $hist(step))]
    } else { set val $hist(minx) }
    .vd.c create line $lft $hist(minyp) $rgt $hist(minyp) -fill red -tags min
    .vd.c create rectangle $rgt [expr $hist(minyp)-3] [expr $rgt+6] [expr $hist(minyp)+3] -fill red -tags min
    .vd.c create text [expr $rgt+7] $hist(minyp) -text $val -anchor w -fill white -tags {min mint}

    .vd.c bind min <B1-Motion> {
	set Pmin(Visibility) [expr round((($hist(base)-%y)*$hist(step) + $hist(minx))*100)/100.]
	.vd.c itemconfigure mint -text $Pmin(Visibility)
	.vd.c move min 0 [expr %y-$hist(minyp)]
	set hist(minyp) %y
    }
    .vd.c bind min <ButtonRelease-1> { make_vis_img; plot_graph }

    set yp  $hist(base)
    set val $Pmax(Visibility)
    set hist(maxyp) $hist(base)	;# pixel-pos des Maximum-sliders
    if {$val != ""} {
	incr hist(maxyp) -[expr round(($val-$hist(minx)) / $hist(step))]
    } else { set val $hist(maxx); incr hist(maxyp) -$hist(size) }
    .vd.c create line $lft $hist(maxyp) $rgt $hist(maxyp) -fill red -tags max
    .vd.c create rectangle $rgt [expr $hist(maxyp)-3] [expr $rgt+6] [expr $hist(maxyp)+3] -fill red -tags max
    .vd.c create text [expr $rgt+7] $hist(maxyp) -text $val -anchor w -fill white -tags {max maxt}

    .vd.c bind max <B1-Motion> {
	set Pmax(Visibility) [expr round((($hist(base)-%y)*$hist(step) + $hist(minx))*100)/100.]
	.vd.c itemconfigure maxt -text $Pmax(Visibility)
	.vd.c move max 0 [expr %y-$hist(maxyp)]
	set hist(maxyp) %y
    }
    .vd.c bind max <ButtonRelease-1> { make_vis_img; plot_graph }
    #
    # Ende des canvas-Krams, jetzt noch Buttons
    #
    button .vd.create -text "Create Mask" -command {
	set V(Mask) "$V(Visib)_msk"; mask create $V(Mask)
    }
    button .vd.clear -text "Clear Mask" -command {
	if {$V(Mask) == ""} { set V(Mask) "$V(Visib)_msk"; mask create $V(Mask) }
	mask clear; make_vis_img; plot_graph
    }
    button .vd.range -text "Mask Cuts" -command {
	if {$V(Mask) == ""} { set V(Mask) "$V(Visib)_msk"; mask create $V(Mask) }
	mask range $Pmin(Visibility) $Pmax(Visibility); make_vis_img; plot_graph
    }
    button .vd.save  -text "Save Mask" -command {
	if {$V(Mask) == ""} { set V(Mask) "$V(Visib)_msk"; mask create $V(Mask) }
	mask save
    }
    button .vd.close -text "Dismiss" -command { destroy .vd }

    pack .vd.create .vd.clear .vd.range .vd.save .vd.close\
	    -side top -padx 1m -pady 3 -expand y -fill x

    if $OPT(debug) {puts "DEBUG: rpt_FileEditMask() finished"}
}

proc dial_rad {rv x y} {
    global V vimg_h vimg_w
    set x [expr $x-$vimg_w/2-1]; set y [expr $vimg_h/2+1-$y]
    set V($rv) [expr round(sqrt($x*$x + $y*$y)/2)]
    cnv_circle [expr 2*$V($rv)] $rv
}

proc cnv_circle {r t} {
    global vimg_h vimg_w
    set w [expr $vimg_w/2+1]
    set h [expr $vimg_h/2+1]
    .vd.c coords $t [expr $w-$r] [expr $h-$r] [expr $w+$r] [expr $h+$r]
}


# --------------------------------------------------------------------
#  rpt_FileCenterPhases
# --------------------------------------------------------------------

proc rpt_FileCenterPhases {} {
    global OPT V
    if $OPT(debug) {puts "DEBUG: rpt_FileCenterPhases()"}

    set res ""
    if {$V(KTphas) == "" && $V(Biphas) == ""} {
	set res "No phase loaded!"
    } else {
	if {$V(KTphas) != ""} { append res [center_phase KT] }
	if {$V(Biphas) != ""} { append res [center_phase Bi] }
    }
    if {$res == ""} {set res "Phases are already centered"}
    tk_dialog .cpd "Center Phases" $res "" -1 "Dismiss"
}


# --------------------------------------------------------------------
#  rpt_FileMaxFromDistance
# --------------------------------------------------------------------

proc rpt_FileMaxFromDistance {} {
    global OPT V mbfr
    if $OPT(debug) {puts "DEBUG: rpt_FileMaxFromDistance()"}

    # 1. Create the top-level window and divide it into top
    # and bottom parts.

    catch {destroy .mbfr}
    toplevel .mbfr -class Dialog
    wm title .mbfr "MaxBright from Radius"
    wm protocol .mbfr WM_DELETE_WINDOW { }

    frame       .mbfr.top -relief raised -bd 1
    label       .mbfr.lMinsep  -text "Min. Sep. of Companion:"
    rkIntEntry	.mbfr.eMinsep -entrywd 5 -textvariable mbfr(Minsep)
		.mbfr.eMinsep_frame configure -bd 0
    bind .mbfr.eMinsep.e <Key> {
	if { "%A" > " " && "%A" != "." && ("%A" < "0" || "%A" >  "9") } {bell; break}
    }
    pack	.mbfr.lMinsep -in .mbfr.top -padx 1m -pady 1m -side left
    pack	.mbfr.eMinsep -in .mbfr.top -padx 1m -pady 1m -side left -fill x -expand y
    pack	.mbfr.top -side top -fill both -expand y

    set mbfr(Minsep) 2
    if [regexp {^SHARP} [get_fitskey "INSTRUME" $V(Visib)]] { set mbfr(Minsep) 3 }

    set mbfr(rifrom) [expr $V(Rmin)-2]; if {$mbfr(rifrom) < 0} {set mbfr(rifrom) 0}
    set mbfr(rito)   [expr $V(Rmin)+2]
    set mbfr(rofrom) [expr $V(Rmax)-6]
    set mbfr(roto)   [expr $V(Rmax)+6]
    set mbfr(ristep) 1
    set mbfr(rostep) 2

    frame       .mbfr.mid -relief raised -bd 1
    label       .mbfr.lScanRange -anchor w -text "Scan Range for Projection Radius:"

    label	.mbfr.lDm	;# grid is doof
    label       .mbfr.lMin -text "From:"
    label       .mbfr.lMax -text "To:"
    label       .mbfr.lStp -text "Step:"

    label	.mbfr.lri -text "Min:"
    label       .mbfr.lro -text "Max:"

    foreach w { rifrom rito ristep rofrom roto rostep } {
	rkIntEntry .mbfr.$w -entrywd 5 -textvariable mbfr($w)
	.mbfr.${w}_frame configure -bd 0
    }
    grid .mbfr.lScanRange -	-		-	-in .mbfr.mid -padx 1m -pady 1m -sticky we
    grid .mbfr.lDm .mbfr.lMin   .mbfr.lMax .mbfr.lStp   -in .mbfr.mid -padx 2m -pady 0m -sticky w
    grid .mbfr.lri .mbfr.rifrom .mbfr.rito .mbfr.ristep -in .mbfr.mid -padx 2m -pady 1m -sticky we
    grid .mbfr.lro .mbfr.rofrom .mbfr.roto .mbfr.rostep -in .mbfr.mid -padx 2m -pady 1m -sticky we

    pack        .mbfr.mid -side top -fill both -expand y

    frame       .mbfr.bot -relief raised -bd 1
    button      .mbfr.bOk     -text "  Ok  " -command { set mbfr(but) 1 }
    button      .mbfr.bCancel -text "Cancel" -command { set mbfr(but) 0 }
    pack        .mbfr.bOk .mbfr.bCancel -in .mbfr.bot -ipadx 2m -pady 2m -side left -expand 1
    pack        .mbfr.bot -side top -fill both

    CenterToplevel .mbfr

    # 7. Wait for the user to respond, then restore the focus and
    # return the index of the selected button.  Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it.  Finally,
    # restore any grab that was in effect.

    tkwait variable mbfr(but)
    if {$mbfr(but) == 0} { destroy .mbfr; return }
    destroy .mbfr.top .mbfr.mid .mbfr.bot

    label .mbfr.hdr -relief raised -bd 1 -padx 1m -pady 1m\
	    -text "Maximum brightness for separation > $mbfr(Minsep)"
    pack  .mbfr.hdr -fill x

    frame .mbfr.ft  -relief raised -bd 1
    text  .mbfr.tab -relief sunken -bd 1 -height 40 -bg MidnightBlue -yscroll ".mbfr.scl set"
    scrollbar .mbfr.scl -relief sunken -orient v -command ".mbfr.tab yview"
    .mbfr.tab tag configure uline -underline y
    .mbfr.tab insert end " Proj-radius   from visib.  at d =       from phases  at d =     \n" uline
    pack  .mbfr.tab -in .mbfr.ft -side left -fill both -expand y
    pack  .mbfr.scl -in .mbfr.ft -side left -fill y -expand y
    pack  .mbfr.ft -fill both -expand y

    frame  .mbfr.bot -relief raised -bd 1
    button .mbfr.dis -text "Dismiss" -command { destroy .mbfr }
    pack   .mbfr.dis -in .mbfr.bot -padx 2m -pady 1m
    pack   .mbfr.bot -fill x

    CenterToplevel .mbfr

    create_clock
    for {set rmin $mbfr(rifrom)} {$rmin <= $mbfr(rito)} {incr rmin $mbfr(ristep)} {
	for {set rmax $mbfr(rofrom)} {$rmax <= $mbfr(roto)} {incr rmax $mbfr(rostep)} {
	    if ![winfo exist .mbfr] { break }
	    set max 0.0
	    set mxr 0.0
	    foreach v [maxbright vis $V(PAmin) $V(PAmax) $V(PAstep) $rmin $rmax] {
		set r  [lindex $v 0]
		set mb [lindex $v 1]
		if {($r >= $mbfr(Minsep)) && ($max < $mb)} { set max $mb; set mxr $r }
	    }
	    if ![winfo exists .mbfr.tab] { break }
	    .mbfr.tab insert end [format "%4d ... %-4d  %10.5f  %7.3f pix" $rmin $rmax $max $mxr]
	    set max 0.0
	    set mxr 0.0
	    foreach v [maxbright pha $V(PAmin) $V(PAmax) $V(PAstep) $rmin $rmax] {
		set r   [lindex $v 0]
		set mb  [lindex $v 1]
		set mb2 [lindex $v 2]
		if {$mb > $mb2} { set mb $mb2 }
		if {($r >= $mbfr(Minsep)) && ($max < $mb)} { set max $mb; set mxr $r }
	    }
	    if ![winfo exists .mbfr.tab] { break }
	    .mbfr.tab insert end [format "   %10.5f  %7.3f pix\n" $max $mxr]
	}
    }
    if [winfo exist .cl] { wm withdraw .cl}
}


# --------------------------------------------------------------------
#  rpt_FileDistanceFromMax
# --------------------------------------------------------------------

proc rpt_FileDistanceFromMax {} {
    global OPT V maxmb rfmb
    if $OPT(debug) {puts "DEBUG: rpt_FileDistanceFromMax()"}

    # 1. Create the top-level window and divide it into top
    # and bottom parts.

    catch {destroy .rfmb}
    toplevel .rfmb -class Dialog
    wm title .rfmb "Radius from MaxBright"
    wm protocol .rfmb WM_DELETE_WINDOW { }

    set	maxmb 0.1
    frame       .rfmb.top -relief raised -bd 1
    label       .rfmb.l -text "Desired maximum brightness:"
    entry       .rfmb.e -wid 5 -textvariable maxmb
    bind	.rfmb.e <Return> { set rfmb(but) 1; break; }
    pack        .rfmb.l -in .rfmb.top -padx 2m -pady 2m -side left
    pack        .rfmb.e -in .rfmb.top -padx 2m -pady 2m -side left -fill x -expand y
    pack	.rfmb.top -side top -fill both -expand y

    frame       .rfmb.bot -relief raised -bd 1
    button      .rfmb.bOk     -text "  Ok  " -command { set rfmb(but) 1 }
    button      .rfmb.bCancel -text "Cancel" -command { set rfmb(but) 0 }
    pack        .rfmb.bOk .rfmb.bCancel -in .rfmb.bot -padx 2m -pady 1m -side left -expand 1
    pack        .rfmb.bot -side top -fill both

    CenterToplevel .rfmb

    # 7. Wait for the user to respond, then restore the focus and
    # return the index of the selected button.  Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it.  Finally,
    # restore any grab that was in effect.

    tkwait variable rfmb(but)
    if {$rfmb(but) == 0} { destroy .rfmb; return }
    destroy .rfmb.top .rfmb.bot

    set minrv 1764
    foreach v [maxbright vis $V(PAmin) $V(PAmax) $V(PAstep) $V(Rmin) $V(Rmax)] {
	set r  [lindex $v 0]
	set mb [lindex $v 1]
	if {($mb < $maxmb) && ($minrv > $r)}   { set minrv $r }
	if {($mb > $maxmb) && ($minrv < 1764)} { set minrv 1764 }
    }
    set minrp 1764
    foreach v [maxbright pha $V(PAmin) $V(PAmax) $V(PAstep) $V(Rmin) $V(Rmax)] {
	set r   [lindex $v 0]
	set mb  [lindex $v 1]
	set mb2 [lindex $v 2]
	if {$mb > $mb2} { set mb $mb2 }
	if {($mb < $maxmb) && ($minrp > $r)}   { set minrp $r }
	if {($mb > $maxmb) && ($minrp < 1764)} { set minrp 1764 }
    }

    frame .rfmb.top -relief raised -bd 1
    label .rfmb.hdr -text "Min. distance for max. brightness < $maxmb"
    label .rfmb.vis -justify r\
	    -text "from visibility: $minrv pix\nfrom phases: $minrp pix"
    pack  .rfmb.hdr .rfmb.vis  -in .rfmb.top -padx 1m -pady 2m -fill x -expand y -padx 1m

    frame  .rfmb.bot -relief raised -bd 1
    button .rfmb.dis -text "Dismiss" -command { destroy .rfmb }
    pack   .rfmb.dis -in .rfmb.bot -padx 2m -pady 1m -expand 1
    pack   .rfmb.top .rfmb.bot -fill x -expand y

    CenterToplevel .rfmb




}

# --------------------------------------------------------------------
#  rpt_FileShowMaxBirhgt
# --------------------------------------------------------------------

proc rpt_FileShowMaxbright {} {
    global OPT V maxmb
    if $OPT(debug) {puts "DEBUG: rpt_FileShowMaxBright"}

    # 1. Create the top-level window and divide it into top
    # and bottom parts.

    catch {destroy .mb}
    toplevel .mb
    wm title .mb "MaxBright values"

    frame .mb.top -relief raised -bd 1
    text  .mb.txt -relief sunken -bd 1 -wid 45 -hei 53 -bg MidnightBlue -yscroll ".mb.scl set"
    scrollbar .mb.scl -relief sunken -orient v -command ".mb.txt yview"
    pack  .mb.txt -in .mb.top -side left -fill both -expand y
    pack  .mb.scl -in .mb.top -side left -fill y
    pack  .mb.top -fill both -expand y

    frame  .mb.bot -relief raised -bd 1
    button .mb.dis -text "Dismiss" -command { destroy .mb }
    pack   .mb.dis -in .mb.bot -padx 2m -pady 1m -expand 1
    pack   .mb.bot -fill x

    .mb.txt tag configure uline -underline y
    .mb.txt insert end "  Radius   from vis. from KT    from Bisp. \n" uline
    set vlst [maxbright vis $V(PAmin) $V(PAmax) $V(PAstep) $V(Rmin) $V(Rmax)]
    set plst [maxbright pha $V(PAmin) $V(PAmax) $V(PAstep) $V(Rmin) $V(Rmax)]

    while {$vlst != "" || $plst != ""} {
	set v  [lindex $vlst 0]
	set p  [lindex $plst 0]

	set rv  [lindex $v 0]; if {$rv == ""} {set rv 999} else {set rv [format "%.3f" $rv]}
	set mbv [lindex $v 1]
	set rp  [lindex $p 0]; if {$rp == ""} {set rp 999} else {set rp [format "%.3f" $rp]}
	set mbK [lindex $p 1]
	set mbB [lindex $p 2]

	if {$rv <= $rp} {
	    .mb.txt insert end [format " %7.3f: %9.6f" $rv $mbv]
	    set vlst [lrange $vlst 1 end]
	} else {
	    .mb.txt insert end [format " %7.3f:          " $rp]
	}
	if {$rp <= $rv} {
	    .mb.txt insert end [format "  %9.6f  %9.6f" $mbK $mbB]
	    set plst [lrange $plst 1 end]
	}
	.mb.txt insert end "\n"
	update
    }
    .mb.txt insert end "  Radius   from vis. from KT    from Bisp. \n" uline
}

# --------------------------------------------------------------------
#  rpt_FileQuit
# --------------------------------------------------------------------

proc rpt_FileQuit {} {
    global OPT V
    if $OPT(debug) {puts "DEBUG: rpt_FileQuit()"}
    exit
}


# --------------------------------------------------------------------
#  rpt_LoadData
# --------------------------------------------------------------------

proc LoadData {msg what filter} {
    global OPT V root
    if $OPT(debug) {puts "DEBUG: LoadData()"}

    set V(All) $V(Visib)
    set nm [rkFileDialog .fd $msg $V($what) $filter]
    if {$nm != {}} {
	if {[regsub "[pwd]/?" $nm "" rest] > 0} {set nm $rest}
	if {$what != "All"} {
	    loadfits $what $nm; set V($what) $nm
	} else {
	    set root $nm
	    regsub {_[^_]+$} $nm "_" root
	    puts "base is $root"
	    if ![catch {loadfits Visib   "${root}tvis" }] { set V(Visib)   ${root}tvis  }
	    if ![catch {loadfits Dvisi   "${root}dtvis"}] { set V(Dvisi)   ${root}dtvis }
	    if ![catch {loadfits KTphas  "${root}ktph" }] { set V(KTphas)  ${root}ktph  }
	    if ![catch {loadfits DKTphas "${root}dktph"}] { set V(DKTphas) ${root}dktph }
	    if ![catch {loadfits Biphas  "${root}biph" }] { set V(Biphas)  ${root}biph  }
	    if ![catch {loadfits DBiphas "${root}dbiph"}] { set V(DBiphas) ${root}dbiph }
	}
	plot_graph
    }
}


# ====================================================================
# Define widgets
# ====================================================================

# --------------------------------------------------------------------
#  define menu
# --------------------------------------------------------------------

frame .menu1 -relief raised -bd 2

# File
menubutton .menu1.mFile -menu .menu1.mFile.m -relief flat -text File -width 8 -anchor w
menu .menu1.mFile.m
.menu1.mFile.m add command -label "Print" -underline 0 -command rpt_FilePrint
.menu1.mFile.m add command -label "Edit Mask" -command rpt_FileEditMask
.menu1.mFile.m add command -label "Center Phases" -command rpt_FileCenterPhases
.menu1.mFile.m add command -label "Max from Distance" -underline 0 -command rpt_FileMaxFromDistance
.menu1.mFile.m add command -label "Distance from Max" -underline 0 -command rpt_FileDistanceFromMax
.menu1.mFile.m add command -label "Show MaxBr.values" -command rpt_FileShowMaxbright
.menu1.mFile.m add command -label "About" -command {
    tk_dialog .abt "About maxbright" [about] "" -1 "Dismiss"
}
.menu1.mFile.m add command -label "Quit" -underline 0 -command rpt_FileQuit

# Load
menubutton .menu1.mLoad -menu .menu1.mLoad.m -relief flat -text Load -width 8 -anchor w
menu .menu1.mLoad.m
.menu1.mLoad.m add command -label Everything	-command { LoadData "Select Something"        All     {*} }
.menu1.mLoad.m add command -label Visibility	-command { LoadData "Select Visibility"       Visib   {*vis} }
.menu1.mLoad.m add command -label DeltaVisib	-command { LoadData "Select Delta Visibility" Dvisi   {*d*vis}}
.menu1.mLoad.m add command -label KT-Phase	-command { LoadData "Select KT-Phase"         KTphas  {*ktph}}
.menu1.mLoad.m add command -label DeltaKTPhase	-command { LoadData "Select Delta KT-Phase"   DKTphas {*dktph}}
.menu1.mLoad.m add command -label BispPhase	-command { LoadData "Select Bisp-Phase"	      Biphas  {*biph}}
.menu1.mLoad.m add command -label DeltaBiPhase	-command { LoadData "Select Delta Bisp-Phase" DBiphas {*dbiph}}
.menu1.mLoad.m add command -label Mask		-command { LoadData "Select Mask"	      Mask    {*m*sk}}

# Show
menubutton .menu1.mShow -menu .menu1.mShow.m -relief flat -text Show -width 8 -anchor w
menu .menu1.mShow.m
.menu1.mShow.m add command -label Visibility    -command { display $V(Visib)  }
.menu1.mShow.m add command -label DeltaVisib    -command { display $V(Dvisi)  }
.menu1.mShow.m add command -label KT-Phase      -command { display $V(KTphas) }
.menu1.mShow.m add command -label DeltaKTPhase  -command { display $V(DKTphas)}
.menu1.mShow.m add command -label BispPhase     -command { display $V(Biphas) }
.menu1.mShow.m add command -label DeltaBiPhase  -command { display $V(DBiphas)}
.menu1.mShow.m add command -label Mask		-command { display $V(Mask)   }

label .menu1.xy -textvariable xypos

pack .menu1.mFile .menu1.mLoad .menu1.mShow -side left -padx .5m
pack .menu1.xy -side right -padx .5m

pack .menu1 -fill x

# --------------------------------------------------------------------
#  Define other widgets
# --------------------------------------------------------------------

frame .f1 -relief raised -bd 1
if [catch "pgplot .f1.plot -width 24c -height 16c -bg MidnightBlue -relief sunken -bd 1 -maxcolors 4"] {
    # smells like the MPIA-bug, try to work around it...
    destroy  .f1
    toplevel .f1 -relief raised -bd 1
    wm title .f1 "Maxbright Plot"
    pgplot	.f1.plot -width 24c -height 16c -bg MidnightBlue -relief sunken -bd 1 -maxcolors 4
} else {
    pack .f1 -expand 1 -fill both
}
pack    .f1.plot -in .f1 -side left  -expand 1 -fill both

#
# Entries for title and files
#
proc labentry {w text var} {
    frame $w
    label $w.l -width 16 -anchor e -text $text
    entry $w.e -width 42 -textvariable $var
    pack $w.l -side left
    pack $w.e -side left -expand y -fill x -padx 2
}

frame       .f2 -relief raised -bd 1
labentry    .f2.f1 "Title:"	  V(Title)
labentry    .f2.f2 "Visibility:"  V(Visib)
labentry    .f2.f3 "Delta Visib:" V(Dvisi)
labentry    .f2.f4 "KT-Phase:"	  V(KTphas)
labentry    .f2.f5 "Delta KT-Phase:" V(DKTphas)
labentry    .f2.f6 "Bisp-Phase:"     V(Biphas)
labentry    .f2.f7 "Delta Bi-Phase:" V(DBiphas)
labentry    .f2.f8 "Mask:"	     V(Mask)
pack .f2.f1 .f2.f2 .f2.f3 .f2.f4 .f2.f5 .f2.f6 .f2.f7 .f2.f8 -expand y -fill x -ipady 2
#
# Entries for projection params
#
frame .rgt -bd 0

proc decrAndPlot {var amt} { global V $var; incr $var -$amt; after 100 plot_graph}

proc scrlentry {w wd text var} {
    frame $w
    label $w.l -width $wd -anchor e -text $text
    entry $w.e -width 6 -textvariable $var
    scrollbar $w.s -width 8 -elementbord 1 -bd 0 -command "decrAndPlot $var"
    pack $w.l -side left
    pack $w.e -side left -expand y -fill x -padx 2
    pack $w.s -side left
    #
    # use scroll-wheel in entry and scrollbar
    #
    bind $w.e <Button-5> "decrAndPlot $var +1"
    bind $w.s <Button-5> "decrAndPlot $var +1"
    bind $w.e <Button-4> "decrAndPlot $var -1"
    bind $w.s <Button-4> "decrAndPlot $var -1"
}

proc change_plot_was {to_was} {
    global plot_was V Pmin Pmax

    #set Pmin($plot_was) $V(Pmin)
    #set Pmax($plot_was) $V(Pmax)
    set plot_was $to_was
    #set V(Pmin) $Pmin($plot_was)
    #set V(Pmax) $Pmax($plot_was)
    .rng.min.e configure -textvar Pmin($plot_was)
    .rng.max.e configure -textvar Pmax($plot_was)
    plot_graph
}

frame .pw -relief raised -bd 1
label .pw.lPlot -text "Plot:"
#
# self-made optionMenu
#
# was: tk_optionMenu .pw.mPlot plot_was Maxbright Visibility KT-Phase Bisp-Phase
set plot_was "Maxbright"
menubutton .pw.mPlot -textvariable plot_was -indicatoron 1 -menu .pw.mPlot.menu \
	-relief raised -bd 1 -highlightthickness 2 -anchor c
menu .pw.mPlot.menu -tearoff 0
foreach i { "Maxbright" "Visibility" "KT-Phase" "Bisp-Phase"} {
    .pw.mPlot.menu add command -label $i -command "change_plot_was $i"
}

.pw.mPlot configure
pack .pw.lPlot .pw.mPlot -side left -padx 1m -pady 0
#
# Projection Angle Range
#
frame      .pa -relief raised -bd 1
label      .lProjectionAngle -anchor w -text "Projection Angle" -pady 3
frame      .pa.f1
frame      .pa.f2
scrlentry  .pa.min 4 "Min:" V(PAmin)
scrlentry  .pa.max 5 "Max:" V(PAmax)
frame	   .pa.dum
label	   .pa.dum.l -width 4
entry	   .pa.dum.e -width 7 -state disabled -relief flat -bg [.pa cget -bg]
pack	   .pa.dum.l -side left
pack	   .pa.dum.e -side left -expand y -fill x -padx 2
scrlentry  .pa.stp 5 "Step:" V(PAstep)
pack    .pa.min	.pa.max	-in .pa.f1 -side left -expand y -fill x
pack	.pa.dum .pa.stp -in .pa.f2 -side left -expand y -fill x
pack    .lProjectionAngle -in .pa -side top -expand y -fill x -padx 1m
pack    .pa.f1 .pa.f2	  -in .pa -side top -expand y -fill x -padx 1m
#
# Radius range
#
frame       .rad -relief raised -bd 1
label       .lRadius -anchor w -text "Radius" -pady 3
frame	    .rad.mm
scrlentry  .rad.min 4 "Min:" V(Rmin)
scrlentry  .rad.max 5 "Max:" V(Rmax)
pack        .rad.min .rad.max -in .rad.mm -side left -expand y -fill x
pack        .lRadius .rad.mm  -in .rad -side top -expand y -fill x -padx 1m
#
# y-range
#
proc smallentry {w wd text var} {
    frame $w
    label $w.l -width $wd -anchor e -text $text
    entry $w.e -width 6 -textvariable $var
    pack $w.l -side left
    pack $w.e -side left -expand y -fill x -padx 2

    bind $w.e <Button-4> "set $var \[expr $$var+0.05\]; plot_graph"
    bind $w.e <Button-5> "set $var \[expr $$var-0.05\]; plot_graph"
}

frame       .rng -relief raised -bd 1
label       .lRanges -anchor w -text "Plot Range" -pady 3
frame       .rng.mm
smallentry  .rng.min 4 "Min:" Pmin($plot_was)
smallentry  .rng.max 5 "Max:" Pmax($plot_was)
pack        .rng.min .rng.max -in .rng.mm -side left -expand y -fill x
pack        .lRanges .rng.mm  -in .rng -side top -expand y -fill x -padx 1m

pack    .pw .pa .rad .rng -in .rgt -expand y -fill both

pack    .f2 .rgt -side left -expand y -fill both

# ====================================================================
# Some bindings
# ====================================================================

bind Entry <Return> {
    global V

    if { $V(PAmin)  == "" } { set V(PAmin)   0}
    if { $V(PAmax)  == "" } { set V(PAmax) 180}
    if { $V(PAstep) == "" } { set V(PAstep) 10}
    if { $V(Rmin)   == "" } { set V(Rmin)    0}
    if { $V(Rmax)   == "" } { set V(Rmin)   42}
    switch %W {
	{.pa.min.e} -
	{.pa.max.e} -
	{.pa.stp.e} -
	{.rad.min.e} -
	{.rad.max.e} -
	{.rng.min.e} -
	{.rng.max.e} { plot_graph }
	{.f2.f2.e} { loadfits Visib $V(Visib); plot_graph }
	{.f2.f3.e} { loadfits Dvisi $V(Dvisi); plot_graph }
	{.f2.f4.e} { loadfits KTphas $V(KTphas); plot_graph }
	{.f2.f5.e} { loadfits DKTphas $V(DKTphas); plot_graph }
	{.f2.f6.e} { loadfits Biphas  $V(Biphas);  plot_graph }
	{.f2.f7.e} { loadfits DBiphas $V(DBiphas); plot_graph }
	{.f2.f8.e} { loadfits Mask    $V(Mask);    plot_graph }
    }
#    set name [string range [file extension %W] 2 end]
#    rpt_$name $V($name)
}

bind . <M-p>	   rpt_FilePrint
bind . <Control-p> rpt_FilePrint
bind . <M-m>	   rpt_FileMaxFromDistance
bind . <Control-m> rpt_FileMaxFromDistance
bind . <M-d>	   rpt_FileDistanceFromMax
bind . <Control-d> rpt_FileDistanceFromMax
bind . <M-q>	   rpt_FileQuit
bind . <Control-q> rpt_FileQuit

#     _/_/_/_/  _/_/_/_/  _/_/_/_/_/
#    _/    _/  _/    _/      _/
#   _/_/_/_/  _/_/_/_/      _/
#  _/  _/    _/            _/
# _/    _/  _/            _/  (C) by AnTu

################################################################################
#
# Default values
#
set root "Maxbright"
set V(PAmin) 0
set V(PAmax) 180
set V(PAstep) 10
set V(Rmin)  0
set V(Rmax) 42
set center 0

################################################################################
#
# some procs
#
proc create_clock {} {
    global V arcID

# too much hassle for an old terminal
#    if ![winfo exists .cl] {
#	 toplevel .cl
#	 wm title .cl "proj-clock"
#	 canvas .cl.c -width 100 -height 100
#	 pack .cl.c
#	 .cl.c create oval 10 10 90 90 -outline white
#	 set arcID [.cl.c create arc  10 10 90 90\
#		 -fill red -start $V(PAmax) -ext [expr $V(PAmin)-$V(PAmax)]]
#	 CenterToplevel .cl
#    } else {
#	 wm deiconify .cl
#    }
}

proc update_clock {ext} {
    global arcID
    if [winfo exists .cl.c] { .cl.c itemconfigure $arcID -ext $ext }
    update
}

proc plot_graph {args} {
    global V Pmin Pmax plot_was

    #puts "plot_graph: $args"

    if {$V(Visib) != "" || $V(KTphas) != "" || $V(Biphas) != ""} {
	if {$plot_was == "Maxbright"} {create_clock}
	#plot $plot_was $V(Pmin) $V(Pmax) $V(PAmin) $V(PAmax) $V(PAstep) $V(Rmin) $V(Rmax)
	plot $plot_was $Pmin($plot_was) $Pmax($plot_was) $V(PAmin) $V(PAmax) $V(PAstep) $V(Rmin) $V(Rmax)
	if [winfo exist .cl] { destroy .cl}
	if [winfo exist .vd] {
	    cnv_circle [expr 2*$V(Rmax)] Rmax
	    cnv_circle [expr 2*$V(Rmin)] Rmin
	}
    }
}


proc check_cent_dialog {w} {
    set check [check_center $w]
    if {$check != ""} {
	return [tk_dialog .cc "Checking centering"\
		"$check\nCenter it now?" question 1 "Forget it" "Center!"]
    }
    return 0
}

proc cent_phase_dialog {w} {
    set res [center_phase $w]
    if {$res != ""} {
	tk_dialog .cc "Result of center_phase" $res info -1 "Dismiss"
    }
}


proc write_maxbright {from_was fname} {
    global V

    set fp [open $fname "w"]

    foreach v [maxbright $from_was $V(PAmin) $V(PAmax) $V(PAstep) $V(Rmin) $V(Rmax)] {
	puts $fp $v
    }
    close $fp
}

################################################################################
#
# Parse command line args
#
proc set_all_files {base} {
    global V root

    set root $base
    set V(Visib)   ${root}tvis
    set V(Dvisi)   ${root}dtvis
    set V(KTphas)  ${root}ktph
    set V(DKTphas) ${root}dktph
    set V(Biphas)  ${root}biph
    set V(DBiphas) ${root}dbiph
}

for {set i 0} {$i < $argc} {incr i} {
    global V

    set opt [lrange $argv $i $i]
    if $OPT(debug) { puts "arg #$i is $opt" }
    incr i
    if {$i < $argc} { set arg [lrange $argv $i $i] } else { set arg "" }

    switch -glob -- $opt {
	{-pmi*} { set Pmin($plot_was) $arg }
	{-pma*} { set Pmax($plot_was) $arg }
	{-rmi*} { set V(Rmin) $arg }
	{-rma*} { set V(Rmax) $arg }
	{-ami*} { set V(PAmin) $arg }
	{-ama*} { set V(PAmax) $arg }
	{-ast*} { set V(PAstep) $arg }
	{-tit*} { eval set V(Title) $arg }
	{-dwim} {
	    regsub {tvis} [lindex [glob *.fits_tvis] end] "" arg
	    set_all_files $arg
	    incr i -1
	}
	{-root} { set_all_files $arg }
	{-dv*}  { set V(Dvisi)  $arg }
	{-dKT*} { set V(DKTphas) $arg }
	{-dBi*} { set V(DBiphas) $arg }
	{-v*}   { set V(Visib)   $arg }
	{-KT*}  { set V(KTphas)  $arg }
	{-Bi*}  { set V(Biphas)  $arg }
	{-mas*} { set V(Mask)    $arg }
	{-c*}   { set center 1; incr i -1 }
	{--h*} -
	{-h*}   {
	    puts " USAGE: $argv0"
	    puts {	[-v visibility] [-KT KT-phase] [-Bi Bisp-Phase]}
	    puts {	[-dv delta-vis] \[-dKT delta-KT-phase] [-dBi delta-Bi-phase]}
	    puts {	[-root root-of-filenames] [-mask mask-file] [-center]}
	    puts {	[-title "Title-string"] [-rmin radius] [-rmax radius]}
	    puts {	[-amin angle] [-amax angle] [-astep step]}
	    puts {	[-pmin value] [-pmax value] [-dwim]}
	    puts ""
	    exit;
	}
	default { error "Unknown option $arg" }
    }
}

if {$V(Title) == ""} {
    if {$V(Visib) != ""} {
	set V(Title) [make_headline $V(Visib)]
	set tmp [rkStringDialog .ttl "Title for Hardcopy" "Please correct the title:" [list $V(Title)]]
	if {$tmp != ""} { set V(Title) $tmp }
    } else {
	set V(Title) "No data loaded.  Please do not expect any fancy graphics!"
    }
}

################################################################################
# Open the widget to PGPLOT.

set plot_id [pgopen ".f1.plot/xtk"]
.f1.plot setcursor cross 14 42 3

################################################################################



foreach w { Visib Dvisi KTphas DKTphas Biphas DBiphas Mask} {
    if { $V($w) != ""} {
	if [catch "loadfits $w $V($w)"] {
	    set V($w) ""
	} elseif [regexp {^..phas$} $w] {
	    if { ($center == 1) || [check_cent_dialog $w]} {
		cent_phase_dialog $w
	    }
	}
    }
}

wm maxsize . 1200 1020
puts [wm maxsize .]
wm title . "MaxBright TNG"
update
plot_graph

#
# Bindings that should be in effect after 1. plot_graph
#
# Arrange for the plot to be redrawn whenever the user resizes it.
bind .f1.plot <Configure> {plot_graph}
bind .f1.plot <Motion> {
    set x [%W world x %x]
    #puts "Motion @ $x"
    if {$x > 300} { set x "inf" } else {
	if {$plot_was == "Maxbright"} { set x [expr pow(10,$x)] }
    }
    set xypos "x = $x, y = [%W world y %y]"
    #puts "Motion finished"
}
